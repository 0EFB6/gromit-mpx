diff -Naur gtk+2.0-2.16.1/gdk/x11/gdkevents-x11.c ../mpx/gtk+2.0-2.16.1/gdk/x11/gdkevents-x11.c
--- gtk+2.0-2.16.1/gdk/x11/gdkevents-x11.c	2009-04-04 06:51:45.000000000 +0200
+++ ../mpx/gtk+2.0-2.16.1/gdk/x11/gdkevents-x11.c	2009-07-06 17:00:30.000000000 +0200
@@ -806,6 +806,15 @@
 	}
     }
   else
+    if(event->type == GenericEvent)
+      {
+	XIEvent* xi_e = (XIEvent*)event;
+	if (xi_e->evtype == XI_Motion ||
+	    xi_e->evtype == XI_ButtonPress ||
+	    xi_e->evtype == XI_ButtonRelease)
+	  *event_window = ((XIDeviceEvent*)xi_e)->event;
+      }
+  else
     {
       GdkDisplayX11 *display_x11 = GDK_DISPLAY_X11 (display);
       GSList *tmp_list;
diff -Naur gtk+2.0-2.16.1/gdk/x11/gdkinput.c ../mpx/gtk+2.0-2.16.1/gdk/x11/gdkinput.c
--- gtk+2.0-2.16.1/gdk/x11/gdkinput.c	2009-04-04 06:51:45.000000000 +0200
+++ ../mpx/gtk+2.0-2.16.1/gdk/x11/gdkinput.c	2009-06-30 17:33:58.000000000 +0200
@@ -114,11 +114,8 @@
   if (gdkdev->display && !GDK_IS_CORE (gdkdev))
     {
 #ifndef XINPUT_NONE
-      if (gdkdev->xdevice)
-        {
-          XCloseDevice (GDK_DISPLAY_XDISPLAY (gdkdev->display), gdkdev->xdevice);
-          gdkdev->xdevice = NULL;
-        }
+      gdkdev->deviceid = -1;
+
       g_free (gdkdev->axes);
       gdkdev->axes = NULL;
 #endif /* !XINPUT_NONE */
@@ -164,7 +161,10 @@
 gdk_display_list_devices (GdkDisplay *display)
 {
   g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);
-  
+
+  /* reload list */
+  g_list_free (GDK_DISPLAY_X11 (display)->input_devices);
+  _gdk_input_common_init (display, 0);      
   return GDK_DISPLAY_X11 (display)->input_devices;
 }
 
diff -Naur gtk+2.0-2.16.1/gdk/x11/gdkinputprivate.h ../mpx/gtk+2.0-2.16.1/gdk/x11/gdkinputprivate.h
--- gtk+2.0-2.16.1/gdk/x11/gdkinputprivate.h	2009-04-02 15:54:55.000000000 +0200
+++ ../mpx/gtk+2.0-2.16.1/gdk/x11/gdkinputprivate.h	2009-06-30 17:29:51.000000000 +0200
@@ -35,7 +35,7 @@
 #include <X11/Xlib.h>
 
 #ifndef XINPUT_NONE
-#include <X11/extensions/XInput.h>
+#include <X11/extensions/XInput2.h>
 #endif
 
 
@@ -75,8 +75,8 @@
   /* information about the axes */
   GdkAxisInfo *axes;
 
-  /* Information about XInput device */
-  XDevice       *xdevice;
+
+ 
 
   /* minimum key code for device */
   gint min_keycode;	       
@@ -181,8 +181,7 @@
 void               _gdk_input_common_find_events        (GdkWindow        *window,
 							 GdkDevicePrivate *gdkdev,
 							 gint              mask,
-							 XEventClass      *classes,
-							 int              *num_classes);
+							 XIEventMask      *eventmask);
 void               _gdk_input_common_select_events      (GdkWindow        *window,
 							 GdkDevicePrivate *gdkdev);
 gint               _gdk_input_common_other_event        (GdkEvent         *event,
diff -Naur gtk+2.0-2.16.1/gdk/x11/gdkinput-x11.c ../mpx/gtk+2.0-2.16.1/gdk/x11/gdkinput-x11.c
--- gtk+2.0-2.16.1/gdk/x11/gdkinput-x11.c	2009-04-04 06:51:45.000000000 +0200
+++ ../mpx/gtk+2.0-2.16.1/gdk/x11/gdkinput-x11.c	2009-07-06 17:02:54.000000000 +0200
@@ -36,7 +36,7 @@
 
 /* Forward declarations */
 static GdkDevicePrivate *gdk_input_device_new            (GdkDisplay       *display,
-							  XDeviceInfo      *device,
+							  XIDeviceInfo      *device,
 							  gint              include_core);
 static void              gdk_input_translate_coordinates (GdkDevicePrivate *gdkdev,
 							  GdkInputWindow   *input_window,
@@ -94,17 +94,17 @@
 
 static GdkDevicePrivate *
 gdk_input_device_new (GdkDisplay  *display,
-		      XDeviceInfo *device, 
+		      XIDeviceInfo *device, 
 		      gint         include_core)
 {
   GdkDevicePrivate *gdkdev;
   gchar *tmp_name;
-  XAnyClassPtr class;
+  XIAnyClassInfo **class;
   gint i,j;
 
   gdkdev = g_object_new (GDK_TYPE_DEVICE, NULL);
 
-  gdkdev->deviceid = device->id;
+  gdkdev->deviceid = device->deviceid;
   gdkdev->display = display;
 
   if (device->name[0])
@@ -132,11 +132,10 @@
   else if (!strcmp (tmp_name, "cursor"))
     gdkdev->info.source = GDK_SOURCE_CURSOR;
   else
-    gdkdev->info.source = GDK_SOURCE_PEN;
+    gdkdev->info.source = GDK_SOURCE_MOUSE;
 
   g_free(tmp_name);
 
-  gdkdev->xdevice = NULL;
 
   /* step through the classes */
 
@@ -150,28 +149,19 @@
   gdkdev->claimed = FALSE;
   gdkdev->button_state = 0;
 
-  class = device->inputclassinfo;
+  class = device->classes;
   for (i=0;i<device->num_classes;i++) 
     {
-      switch (class->class) {
-      case ButtonClass:
+      switch (class[i]->type) {
+      case XIButtonClass:
 	break;
-      case KeyClass:
+      case XIKeyClass:
 	{
-	  XKeyInfo *xki = (XKeyInfo *)class;
-	  /* Hack to catch XFree86 3.3.1 bug. Other devices better
-	   * not have exactly 25 keys... 
-	   */
-	  if ((xki->min_keycode == 8) && (xki->max_keycode == 32))
-	    {
-	      gdkdev->info.num_keys = 32;
-	      gdkdev->min_keycode = 1;
-	    }
-	  else
-	    {
-	      gdkdev->info.num_keys = xki->max_keycode - xki->min_keycode + 1;
-	      gdkdev->min_keycode = xki->min_keycode;
-	    }
+	  fprintf(stderr, "GDK XINPUT2:    has KeyClass\n");
+	  XIKeyClassInfo *xki = (XIKeyClassInfo *)class;
+	  
+	  gdkdev->info.num_keys = xki->num_keycodes;
+
 	  gdkdev->info.keys = g_new (GdkDeviceKey, gdkdev->info.num_keys);
 
 	  for (j=0; j<gdkdev->info.num_keys; j++)
@@ -182,27 +172,35 @@
 
 	  break;
 	}
-      case ValuatorClass:
+      case XIValuatorClass:
 	{
-	  XValuatorInfo *xvi = (XValuatorInfo *)class;
-	  gdkdev->info.num_axes = xvi->num_axes;
-	  gdkdev->axes = g_new (GdkAxisInfo, xvi->num_axes);
-	  gdkdev->info.axes = g_new0 (GdkDeviceAxis, xvi->num_axes);
-	  for (j=0;j<xvi->num_axes;j++)
+	  fprintf(stderr, "GDK XINPUT2:     has ValuatorClass\n");
+	  
+	  /* this is UGLY */
+	  XIValuatorClassInfo *xvi = (XIValuatorClassInfo *)class;
+	  gdkdev->info.num_axes++;
+	  g_free(gdkdev->axes);
+	  gdkdev->axes = g_new(GdkAxisInfo,gdkdev->info.num_axes);
+
+	  g_free(gdkdev->info.axes);
+	  gdkdev->info.axes = g_new0 (GdkDeviceAxis,gdkdev->info.num_axes);
+
+	  for (j=0;j< gdkdev->info.num_axes;j++)
 	    {
 	      gdkdev->axes[j].resolution = 
-		gdkdev->axes[j].xresolution = xvi->axes[j].resolution;
+		gdkdev->axes[j].xresolution = xvi->resolution;
 	      gdkdev->axes[j].min_value =
-		gdkdev->axes[j].xmin_value = xvi->axes[j].min_value;
+		gdkdev->axes[j].xmin_value = xvi->min;
 	      gdkdev->axes[j].max_value =
-		gdkdev->axes[j].xmax_value = xvi->axes[j].max_value;
+		gdkdev->axes[j].xmax_value = xvi->max;
 	      gdkdev->info.axes[j].use = GDK_AXIS_IGNORE;
 	    }
 	  j=0;
-	  if (j<xvi->num_axes)
-	    gdk_device_set_axis_use (&gdkdev->info, j++, GDK_AXIS_X);
-	  if (j<xvi->num_axes)
-	    gdk_device_set_axis_use (&gdkdev->info, j++, GDK_AXIS_Y);
+	  if (gdkdev->info.num_axes == 1)
+	    gdk_device_set_axis_use (&gdkdev->info, 0, GDK_AXIS_X);
+	  if (gdkdev->info.num_axes == 2)
+	    gdk_device_set_axis_use (&gdkdev->info, 1, GDK_AXIS_Y);
+	  /*
 	  if (j<xvi->num_axes)
 	    gdk_device_set_axis_use (&gdkdev->info, j++, GDK_AXIS_PRESSURE);
 	  if (j<xvi->num_axes)
@@ -211,27 +209,24 @@
 	    gdk_device_set_axis_use (&gdkdev->info, j++, GDK_AXIS_YTILT);
 	  if (j<xvi->num_axes)
 	    gdk_device_set_axis_use (&gdkdev->info, j++, GDK_AXIS_WHEEL);
-		       
+	  */
+	  	       
 	  break;
 	}
       }
-      class = (XAnyClassPtr)(((char *)class) + class->length);
+    
     }
+    
+  fprintf(stderr, "GDK XINPUT2:     is called %s\n", gdkdev->info.name);
+
+  fprintf(stderr, "GDK XINPUT2:     is master pointer: %i\n", device->use == XIMasterPointer);
+  
   /* return NULL if no axes */
-  if (!gdkdev->info.num_axes || !gdkdev->axes ||
-      (!include_core && device->use == IsXPointer))
+  if (!gdkdev->info.num_axes || !gdkdev->axes)
     goto error;
 
-  if (device->use != IsXPointer)
-    {
-      gdk_error_trap_push ();
-      gdkdev->xdevice = XOpenDevice (GDK_DISPLAY_XDISPLAY (display),
-				     gdkdev->deviceid);
-
-      /* return NULL if device is not ready */
-      if (gdk_error_trap_pop ())
-	goto error;
-    }
+  fprintf(stderr, "GDK XINPUT2    has %d axes\n",gdkdev->info.num_axes );
+  
 
   gdkdev->buttonpress_type = 0;
   gdkdev->buttonrelease_type = 0;
@@ -255,35 +250,19 @@
 _gdk_input_common_find_events(GdkWindow *window,
 			      GdkDevicePrivate *gdkdev,
 			      gint mask,
-			      XEventClass *classes,
-			      int *num_classes)
+			      XIEventMask *eventmask)
 {
-  gint i;
-  XEventClass class;
-  
-  i = 0;
   if (mask & GDK_BUTTON_PRESS_MASK)
     {
-      DeviceButtonPress (gdkdev->xdevice, gdkdev->buttonpress_type,
-			     class);
-      if (class != 0)
-	  classes[i++] = class;
-      DeviceButtonPressGrab (gdkdev->xdevice, 0, class);
-      if (class != 0)
-	  classes[i++] = class;
+      XISetMask(eventmask->mask, XI_ButtonPress);
     }
   if (mask & GDK_BUTTON_RELEASE_MASK)
     {
-      DeviceButtonRelease (gdkdev->xdevice, gdkdev->buttonrelease_type,
-			   class);
-      if (class != 0)
-	  classes[i++] = class;
+      XISetMask(eventmask->mask, XI_ButtonRelease);
     }
   if (mask & GDK_POINTER_MOTION_MASK)
     {
-      DeviceMotionNotify  (gdkdev->xdevice, gdkdev->motionnotify_type, class);
-      if (class != 0)
-	  classes[i++] = class;
+      XISetMask(eventmask->mask, XI_Motion);
     }
   else
     if (mask & (GDK_BUTTON1_MOTION_MASK | GDK_BUTTON2_MOTION_MASK |
@@ -291,120 +270,116 @@
 		GDK_POINTER_MOTION_HINT_MASK))
       {
 	/* Make sure gdkdev->motionnotify_type is set */
-	DeviceMotionNotify  (gdkdev->xdevice, gdkdev->motionnotify_type, class);
+	gdkdev->motionnotify_type = XI_Motion;
       }
   if (mask & GDK_BUTTON1_MOTION_MASK)
     {
-      DeviceButton1Motion  (gdkdev->xdevice, 0, class);
-      if (class != 0)
-	  classes[i++] = class;
+      XISetMask(eventmask->mask, XI_Motion);
+      XISetMask(eventmask->mask, XI_ButtonPress);
     }
   if (mask & GDK_BUTTON2_MOTION_MASK)
     {
-      DeviceButton2Motion  (gdkdev->xdevice, 0, class);
-      if (class != 0)
-	  classes[i++] = class;
+      XISetMask(eventmask->mask, XI_Motion);
+      XISetMask(eventmask->mask, XI_ButtonPress);
     }
   if (mask & GDK_BUTTON3_MOTION_MASK)
     {
-      DeviceButton3Motion  (gdkdev->xdevice, 0, class);
-      if (class != 0)
-	  classes[i++] = class;
+      XISetMask(eventmask->mask, XI_Motion);
+      XISetMask(eventmask->mask, XI_ButtonPress);
     }
   if (mask & GDK_BUTTON_MOTION_MASK)
     {
-      DeviceButtonMotion  (gdkdev->xdevice, 0, class);
-      if (class != 0)
-	  classes[i++] = class;
+      XISetMask(eventmask->mask, XI_Motion);
+      XISetMask(eventmask->mask, XI_ButtonPress);
     }
   if (mask & GDK_POINTER_MOTION_HINT_MASK)
     {
       /* We'll get into trouble if the macros change, but at least we'll
 	 know about it, and we avoid warnings now */
-      DevicePointerMotionHint (gdkdev->xdevice, 0, class);
-      if (class != 0)
-	  classes[i++] = class;
+      XISetMask(eventmask->mask, XI_Motion);
     }
   if (mask & GDK_KEY_PRESS_MASK)
     {
-      DeviceKeyPress (gdkdev->xdevice, gdkdev->keypress_type, class);
-      if (class != 0)
-	  classes[i++] = class;
+      XISetMask(eventmask->mask, XI_KeyPress);
     }
   if (mask & GDK_KEY_RELEASE_MASK)
     {
-      DeviceKeyRelease (gdkdev->xdevice, gdkdev->keyrelease_type, class);
-      if (class != 0)
-	  classes[i++] = class;
-    }
-  if (mask & GDK_PROXIMITY_IN_MASK)
-    {
-      ProximityIn   (gdkdev->xdevice, gdkdev->proximityin_type, class);
-      if (class != 0)
-	  classes[i++] = class;
+      XISetMask(eventmask->mask, XI_KeyRelease);
     }
-  if (mask & GDK_PROXIMITY_OUT_MASK)
-    {
-      ProximityOut  (gdkdev->xdevice, gdkdev->proximityout_type, class);
-      if (class != 0)
-	  classes[i++] = class;
-    }
-
-  *num_classes = i;
 }
 
 void
 _gdk_input_common_select_events(GdkWindow *window,
 				GdkDevicePrivate *gdkdev)
 {
-  XEventClass classes[GDK_MAX_DEVICE_CLASSES];
-  gint num_classes;
+  XIEventMask eventmask;
+  unsigned char bits[GDK_MAX_DEVICE_CLASSES] = {0};
+  eventmask.mask = bits;
+  eventmask.mask_len = sizeof(bits);
+  eventmask.deviceid = gdkdev->deviceid;
+
 
   if (gdkdev->info.mode == GDK_MODE_DISABLED)
-    _gdk_input_common_find_events(window, gdkdev, 0, classes, &num_classes);
+    _gdk_input_common_find_events(window, gdkdev, 0, &eventmask);
   else
     _gdk_input_common_find_events(window, gdkdev, 
 				  ((GdkWindowObject *)window)->extension_events,
-				  classes, &num_classes);
+				  &eventmask);
   
-  XSelectExtensionEvent (GDK_WINDOW_XDISPLAY (window),
-			 GDK_WINDOW_XWINDOW (window),
-			 classes, num_classes);
+  XISelectEvents(GDK_WINDOW_XDISPLAY (window), GDK_WINDOW_XWINDOW (window) , &eventmask, 1);
+
 }
 
 gint 
 _gdk_input_common_init (GdkDisplay *display,
 			gint        include_core)
 {
-  XDeviceInfo   *devices;
+  XIDeviceInfo   *devices;
   int num_devices, loop;
   int ignore, event_base;
   GdkDisplayX11 *display_x11 = GDK_DISPLAY_X11 (display);
 
   /* Init XInput extension */
-
+ 
   display_x11->input_devices = NULL;
   if (XQueryExtension (display_x11->xdisplay, "XInputExtension",
 		       &ignore, &event_base, &ignore))
     {
+      // announce support for XI2
+      int major = 2, minor = 0;
+      if (XIQueryVersion(display_x11->xdisplay, &major, &minor) == BadRequest) 
+	return FALSE;
+
       gdk_x11_register_standard_event_type (display,
 					    event_base, 15 /* Number of events */);
 
-      devices = XListInputDevices(display_x11->xdisplay, &num_devices);
+      
+      devices = XIQueryDevice(display_x11->xdisplay, XIAllDevices, &num_devices);
+
+      fprintf(stderr, "GDK XINPUT2 %i MD/SD devices found\n", num_devices);
   
       for(loop=0; loop<num_devices; loop++)
 	{
-	  GdkDevicePrivate *gdkdev = gdk_input_device_new(display,
+	  XIDeviceInfo* current = &devices[loop];
+          if(current->use == XIMasterPointer || current->use == XIMasterKeyboard)
+            { 
+               fprintf(stderr, "\nGDK XINPUT2 Found MD: %s (%d)\n",
+		       current->name, current->deviceid);
+
+               GdkDevicePrivate *gdkdev = gdk_input_device_new(display,
 							  &devices[loop],
 							  include_core);
-	  if (gdkdev)
-	    display_x11->input_devices = g_list_append(display_x11->input_devices, gdkdev);
+	       if (gdkdev) 
+		 {
+		   fprintf(stderr, "GDK XINPUT2 gdkdev created successfully\n"); 	  
+		   display_x11->input_devices = g_list_append(display_x11->input_devices, gdkdev);
+		 }
+            }
 	}
-      XFreeDeviceList(devices);
+      XIFreeDeviceInfo(devices);
     }
 
-  display_x11->input_devices = g_list_append (display_x11->input_devices, display->core_pointer);
-
+ 
   return TRUE;
 }
 
@@ -534,7 +509,7 @@
 static guint
 gdk_input_translate_state(guint state, guint device_state)
 {
-  return device_state | (state & 0xFF);
+  return (device_state << 7) | (state & 0xFF);
 }
 
 
@@ -544,33 +519,47 @@
 			       GdkInputWindow   *input_window,
 			       GdkDevicePrivate *gdkdev)
 {
-  if ((xevent->type == gdkdev->buttonpress_type) ||
-      (xevent->type == gdkdev->buttonrelease_type)) 
+  XIEvent* xi_e = NULL;
+
+  if(xevent->type == GenericEvent)
+    xi_e = (XIEvent*) xevent;
+  else
+    return FALSE;
+
+ 
+
+  if (xi_e->evtype == XI_ButtonPress || xi_e->evtype == XI_ButtonRelease)
     {
-      XDeviceButtonEvent *xdbe = (XDeviceButtonEvent *)(xevent);
+      XIDeviceEvent *xdbe = (XIDeviceEvent *)(xevent);
 
-      if (xdbe->type == gdkdev->buttonpress_type)
+      if (xdbe->evtype == XI_ButtonPress)
 	{
 	  event->button.type = GDK_BUTTON_PRESS;
-	  gdkdev->button_state |= 1 << xdbe->button;
+	  gdkdev->button_state |= 1 << xdbe->detail;
 	}
       else
 	{
 	  event->button.type = GDK_BUTTON_RELEASE;
-	  gdkdev->button_state &= ~(1 << xdbe->button);
+	  gdkdev->button_state &= ~(1 << xdbe->detail);
 	}
+
+     
       event->button.device = &gdkdev->info;
       event->button.window = input_window->window;
       event->button.time = xdbe->time;
 
       event->button.axes = g_new (gdouble, gdkdev->info.num_axes);
-      gdk_input_translate_coordinates (gdkdev,input_window, xdbe->axis_data,
-				       event->button.axes, 
-				       &event->button.x,&event->button.y);
+
+      event->button.x = xdbe->event_x;
+      event->button.y = xdbe->event_y;
+
       event->button.x_root = event->button.x + input_window->root_x;
       event->button.y_root = event->button.y + input_window->root_y;
-      event->button.state = gdk_input_translate_state(xdbe->state,xdbe->device_state);
-      event->button.button = xdbe->button;
+     
+      event->button.state = gdk_input_translate_state(0x10,gdkdev->button_state);
+      
+      event->button.button = xdbe->detail;
+
 
       if (event->button.type == GDK_BUTTON_PRESS)
 	_gdk_event_button_generate (gdk_drawable_get_display (event->button.window),
@@ -579,10 +568,10 @@
       GDK_NOTE (EVENTS,
 	g_print ("button %s:\t\twindow: %ld  device: %ld  x,y: %f %f  button: %d\n",
 		 (event->button.type == GDK_BUTTON_PRESS) ? "press" : "release",
-		 xdbe->window,
+		 xdbe->event,
 		 xdbe->deviceid,
 		 event->button.x, event->button.y,
-		 xdbe->button));
+		 xdbe->detail));
 
       /* Update the timestamp of the latest user interaction, if the event has
        * a valid timestamp.
@@ -593,26 +582,20 @@
       return TRUE;
   }
 
-  if ((xevent->type == gdkdev->keypress_type) ||
-      (xevent->type == gdkdev->keyrelease_type))
+  if ((xi_e->evtype == XI_KeyPress) ||
+      (xi_e->evtype == XI_KeyRelease))
     {
-      XDeviceKeyEvent *xdke = (XDeviceKeyEvent *)(xevent);
+      XIDeviceEvent *xdke = (XIDeviceEvent *)(xevent);
 
       GDK_NOTE (EVENTS,
 	g_print ("device key %s:\twindow: %ld  device: %ld  keycode: %d\n",
 		 (event->key.type == GDK_KEY_PRESS) ? "press" : "release",
 		 xdke->window,
 		 xdke->deviceid,
-		 xdke->keycode));
+		 xdke->detail));
 
-      if (xdke->keycode < gdkdev->min_keycode ||
-	  xdke->keycode >= gdkdev->min_keycode + gdkdev->info.num_keys)
-	{
-	  g_warning ("Invalid device key code received");
-	  return FALSE;
-	}
-      
-      event->key.keyval = gdkdev->info.keys[xdke->keycode - gdkdev->min_keycode].keyval;
+           
+      event->key.keyval = gdkdev->info.keys[xdke->detail].keyval;
 
       if (event->key.keyval == 0) 
 	{
@@ -628,8 +611,8 @@
       event->key.window = input_window->window;
       event->key.time = xdke->time;
 
-      event->key.state = gdk_input_translate_state(xdke->state, xdke->device_state)
-	| gdkdev->info.keys[xdke->keycode - gdkdev->min_keycode].modifiers;
+      // event->key.state = gdk_input_translate_state(xdke->state, xdke->device_state)
+      //	| gdkdev->info.keys[xdke->keycode - gdkdev->min_keycode].modifiers;
 
       /* Add a string translation for the key event */
       if ((event->key.keyval >= 0x20) && (event->key.keyval <= 0xFF))
@@ -659,29 +642,40 @@
       return TRUE;
     }
 
-  if (xevent->type == gdkdev->motionnotify_type) 
+  if (xi_e->evtype == XI_Motion) 
     {
-      XDeviceMotionEvent *xdme = (XDeviceMotionEvent *)(xevent);
+      XIDeviceEvent *xdme = (XIDeviceEvent *)(xevent);
+
+      if((((GdkWindowObject *)input_window->window)->extension_events & GDK_BUTTON_MOTION_MASK) &&
+	 ! XIMaskIsSet(xdme->buttons->mask, 1) &&
+	 ! XIMaskIsSet(xdme->buttons->mask, 2) &&
+	 ! XIMaskIsSet(xdme->buttons->mask, 3))
+	return FALSE;
 
+	  
       event->motion.device = &gdkdev->info;
       
       event->motion.axes = g_new (gdouble, gdkdev->info.num_axes);
-      gdk_input_translate_coordinates(gdkdev,input_window,xdme->axis_data,
-				      event->motion.axes,
-				      &event->motion.x,&event->motion.y);
+
+    
+      event->motion.x = xdme->event_x;
+      event->motion.y = xdme->event_y;
+				      
       event->motion.x_root = event->motion.x + input_window->root_x;
       event->motion.y_root = event->motion.y + input_window->root_y;
 
       event->motion.type = GDK_MOTION_NOTIFY;
       event->motion.window = input_window->window;
       event->motion.time = xdme->time;
-      event->motion.state = gdk_input_translate_state(xdme->state,
-						      xdme->device_state);
-      event->motion.is_hint = xdme->is_hint;
+      //      event->motion.state = gdkdev->button_state;
+      event->motion.state = gdk_input_translate_state( 0x10,
+						       gdkdev->button_state);
+
+      //event->motion.is_hint = xdme->is_hint;
 
       GDK_NOTE (EVENTS,
-	g_print ("motion notify:\t\twindow: %ld  device: %ld  x,y: %f %f  state %#4x  hint: %s\n",
-		 xdme->window,
+	g_print ("motion notify:\t\twindow: %ld  device: %ld  x,y: %f %f  state %#4x\n",
+		 xdme->event,
 		 xdme->deviceid,
 		 event->motion.x, event->motion.y,
 		 event->motion.state,
@@ -697,7 +691,7 @@
       return TRUE;
     }
 
-  if (xevent->type == gdkdev->proximityin_type ||
+  /* if (xevent->type == gdkdev->proximityin_type ||
       xevent->type == gdkdev->proximityout_type)
     {
       XProximityNotifyEvent *xpne = (XProximityNotifyEvent *)(xevent);
@@ -708,14 +702,14 @@
       event->proximity.window = input_window->window;
       event->proximity.time = xpne->time;
       
-      /* Update the timestamp of the latest user interaction, if the event has
-       * a valid timestamp.
-       */
+      // Update the timestamp of the latest user interaction, if the event has
+      // a valid timestamp.
+       
       if (gdk_event_get_time (event) != GDK_CURRENT_TIME)
         gdk_x11_window_set_user_time (gdk_window_get_toplevel (input_window->window),
                                       gdk_event_get_time (event));
       return TRUE;
-  }
+  }*/
 
   return FALSE;			/* wasn't one of our event types */
 }
@@ -728,6 +722,9 @@
 			 GdkTimeCoord    ***events,
 			 gint              *n_events)
 {
+  return FALSE;
+  /*
+
   GdkTimeCoord **coords;
   XDeviceTimeCoord *device_coords;
   GdkInputWindow *input_window;
@@ -747,6 +744,7 @@
 					  n_events, &mode_return,
 					  &axis_count_return);
 
+    
   if (device_coords)
     {
       coords = _gdk_device_allocate_history (device, *n_events);
@@ -768,6 +766,7 @@
     }
   else
     return FALSE;
+  */
 }
 
 void 
@@ -778,6 +777,9 @@
 {
   gint i;
 
+  // disabled for now
+  return;
+  /*
   g_return_if_fail (device != NULL);
   g_return_if_fail (GDK_IS_WINDOW (window));
 
@@ -827,8 +829,8 @@
 		  *mask &= 0xFF;
 		  if (((XButtonState *)input_class)->num_buttons > 0)
 		    *mask |= ((XButtonState *)input_class)->buttons[0] << 7;
-		  /* GDK_BUTTON1_MASK = 1 << 8, and button n is stored
-		   * in bit 1<<(n%8) in byte n/8. n = 1,2,... */
+		  // GDK_BUTTON1_MASK = 1 << 8, and button n is stored
+		  // in bit 1<<(n%8) in byte n/8. n = 1,2,... 
 		}
 	      break;
 	    }
@@ -836,6 +838,7 @@
 	}
       XFreeDeviceState (state);
     }
+*/
 }
 
 #define __GDK_INPUT_X11_C__
diff -Naur gtk+2.0-2.16.1/gdk/x11/gdkinput-xfree.c ../mpx/gtk+2.0-2.16.1/gdk/x11/gdkinput-xfree.c
--- gtk+2.0-2.16.1/gdk/x11/gdkinput-xfree.c	2009-04-04 06:51:45.000000000 +0200
+++ ../mpx/gtk+2.0-2.16.1/gdk/x11/gdkinput-xfree.c	2009-07-03 13:45:57.000000000 +0200
@@ -102,6 +102,11 @@
 static void
 gdk_input_check_proximity (GdkDisplay *display)
 {
+  // disabled for now
+  return;
+
+  /*
+
   gint new_proximity = 0;
   GdkDisplayX11 *display_impl = GDK_DISPLAY_X11 (display);
   GList *tmp_list = display_impl->input_devices;
@@ -140,6 +145,8 @@
     }
 
   display_impl->input_ignore_core = new_proximity;
+
+  */
 }
 
 void
@@ -186,7 +193,7 @@
 			GdkWindow *window)
 {
   GdkInputWindow *input_window;
-  
+
   GdkDevicePrivate *gdkdev;
   gint return_val;
   GdkDisplayX11 *display_impl = GDK_DISPLAY_X11 (GDK_WINDOW_DISPLAY (window));
@@ -199,7 +206,8 @@
      every device. If we were deceived, then it won't match any of
      the types for the device anyways */
   gdkdev = _gdk_input_find_device (GDK_WINDOW_DISPLAY (window),
-				   ((XDeviceButtonEvent *)xevent)->deviceid);
+				   ((XIDeviceEvent *)xevent)->deviceid);
+
   if (!gdkdev)
     return FALSE;			/* we don't handle it - not an XInput event */
 
@@ -245,7 +253,11 @@
 			 GdkWindow *     confine_to,
 			 guint32         time)
 {
-  GdkInputWindow *input_window, *new_window;
+  // disabled
+  return FALSE;
+
+  /*
+ GdkInputWindow *input_window, *new_window;
   gboolean need_ungrab;
   GdkDevicePrivate *gdkdev;
   GList *tmp_list;
@@ -296,8 +308,8 @@
 				      owner_events, num_classes, event_classes,
 				      GrabModeAsync, GrabModeAsync, time);
 	      
-	      /* FIXME: if failure occurs on something other than the first
-		 device, things will be badly inconsistent */
+	      // FIXME: if failure occurs on something other than the first
+	      //	 device, things will be badly inconsistent 
 	      if (result != Success)
 		return result;
 	    }
@@ -322,14 +334,19 @@
     }
 
   return Success;
-      
+  */    
 }
 
 void 
 _gdk_input_ungrab_pointer (GdkDisplay *display, 
 			   guint32 time)
 {
-  GdkInputWindow *input_window = NULL; /* Quiet GCC */
+  // disabled
+  return;
+
+  /*
+
+  GdkInputWindow *input_window = NULL; // Quiet GCC
   GdkDevicePrivate *gdkdev;
   GList *tmp_list;
   GdkDisplayX11 *display_impl = GDK_DISPLAY_X11 (display);
@@ -343,7 +360,7 @@
       tmp_list = tmp_list->next;
     }
 
-  if (tmp_list)			/* we found a grabbed window */
+  if (tmp_list)			// we found a grabbed window 
     {
       input_window->grabbed = FALSE;
 
@@ -357,6 +374,7 @@
 	  tmp_list = tmp_list->next;
 	}
     }
+  */
 }
 
 #define __GDK_INPUT_XFREE_C__
